package org.example;

import java.awt.*;
import java.util.Arrays;

// 추상클래스 설명 250312


class Main {
    public static void main(String[] args) {
        // * double d = 5.5; 의 처리과정
        // 1 : 실수 5.5가 생긴다.
        // 2 : 오직 실수만 담을 수 있는 변수 d가 생성된다.
        // 3 : d는 5.5가 자신안에 들어 올 수 있는지 판단한다.(가능)
        // 4 : d변수에 실수 5.5가 들어간다.
        double d = 5.5;

        // * double dd = 5; 의 처리과정
        // 1 : 정수 5가 생긴다.
        // 2 : 오직 실수만 담을 수 있는 변수 dd가 생성된다.
        // 3 : dd는 5가 자신안에 들어 올 수 있는지 판단한다.
        // 4 : 5는 정수이기 때문에 들어 올 수 없다고 판단한다.(불가능)
        // 5 : dd가 아쉬워하는 5에게 이렇게 이야기 합니다. `니가 실수로 변환될 수 있다면 들어올 수 있다.`
        // 6 : 5는 자신의 형태를 버리고 실수화 한다. 즉 5.0으로 변신하다.(캐스팅, 또는 형변환)
        // 7 : dd로 5.0이 들어간다.
        double dd = 5;

        // * int i = 5.5; 의 처리과정
        // 1 : 실수 5.5가 생긴다.
        // 2 : 오직 정수만 담을 수 있는 변수 i가 생성된다.
        // 3 : i는 5.5가 자신에게 담길 수 있는지 체크한다.(불가능)
        // 4 : i는 아쉬워하는 5.5에게 이렇게 이야기 합니다. `니가 정수가 된다면 들어올 수 있다.`
        // 5 : 5.5는 도저히 불가능 요구를 받고 치명적인 에러를 발생시킨다.(캐스팅 불가능 으로 인한 에러)
        //int i = 5.5;
        int i = (int)5.5; // 대신 강제 형변환으로 5.5를 정수형으로 바꿈

        // * 무기 a무기 = new 칼(); 의 처리과정
        // 1. 오직 무기 리모컨만 담을 수 있는 a무기 변수에 칼 클래스로 만든 객체를 연결한다.
        // 2. 칼 클래스는 무기 클래스를 상속 받기 때문에 칼 클래스로 만든 객체를 무기 리모컨 저장소에 저장할 수 있다.
        // 3. 대신 칼 클래스는 무기 클래스와 같은 속성과 모양을 갖거나 더 적어야한다?
        // * a무기.공격(); 의 처리과정
        // 1. 칼 객체에는 공격 메서드가 없다.
        // 2. 하지만 칼 객체는 무기 클래스를 상속받기 때문에 상위 클래스의 메서드인 공격 메서드를 이용할 수 있다.
        // 3. 상위 클래스의 속성과 기능을 복사하는 것이 아니라 연결되어 사용할 수 있는 것이다.
        무기 a무기 = new 칼();
        a무기.공격();

        칼 a칼 = new 칼();

        a칼 = new 활();

    }
}

class 무기 {
    void 공격() {
        System.out.println("칼로 공격합니다.");
    }
}

class 칼 extends 무기 {

}

class 활 extends 칼 {

}

